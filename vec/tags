!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Vec	vec.h	/^	Vec() { create(); }$/;"	f	class:Vec	access:public	signature:()
Vec	vec.h	/^	Vec(const Vec& v) { create(v.begin(), v.end()); }$/;"	f	class:Vec	access:public	signature:(const Vec& v)
Vec	vec.h	/^  	explicit Vec(size_type n, const T& t = T()) { create(n, t); }$/;"	f	class:Vec	access:public	signature:(size_type n, const T& t = T())
Vec	vec.h	/^class Vec {$/;"	c
Vec::Vec	vec.h	/^	Vec() { create(); }$/;"	f	class:Vec	access:public	signature:()
Vec::Vec	vec.h	/^	Vec(const Vec& v) { create(v.begin(), v.end()); }$/;"	f	class:Vec	access:public	signature:(const Vec& v)
Vec::Vec	vec.h	/^  	explicit Vec(size_type n, const T& t = T()) { create(n, t); }$/;"	f	class:Vec	access:public	signature:(size_type n, const T& t = T())
Vec::alloc	vec.h	/^	allocator<T> alloc;$/;"	m	class:Vec	access:private
Vec::avail	vec.h	/^	iterator avail; \/\/ one past last element in the Vec$/;"	m	class:Vec	access:private
Vec::begin	vec.h	/^	const_iterator begin() { return data; }$/;"	f	class:Vec	access:public	signature:()
Vec::begin	vec.h	/^	iterator begin() { return data; }$/;"	f	class:Vec	access:public	signature:()
Vec::const_iterator	vec.h	/^	typedef const T* const_iterator;$/;"	t	class:Vec	access:public
Vec::const_reference	vec.h	/^	typedef const T& const_reference;$/;"	t	class:Vec	access:public
Vec::create	vec.h	/^	void create();$/;"	p	class:Vec	access:private	signature:()
Vec::create	vec.h	/^	void create(const_iterator, const_iterator);$/;"	p	class:Vec	access:private	signature:(const_iterator, const_iterator)
Vec::create	vec.h	/^	void create(size_type, const T&);$/;"	p	class:Vec	access:private	signature:(size_type, const T&)
Vec::data	vec.h	/^	iterator data; \/\/ first element in the Vec$/;"	m	class:Vec	access:private
Vec::end	vec.h	/^	const_iterator end() const { return avail; }$/;"	f	class:Vec	access:public	signature:() const
Vec::end	vec.h	/^	iterator end() const { return avail; }$/;"	f	class:Vec	access:public	signature:() const
Vec::grow	vec.h	/^	void grow();$/;"	p	class:Vec	access:private	signature:()
Vec::iterator	vec.h	/^	typedef T* iterator;$/;"	t	class:Vec	access:public
Vec::limit	vec.h	/^	iterator limit; \/\/ one past allocated array$/;"	m	class:Vec	access:private
Vec::operator =	vec.h	/^	Vec& operator=(const Vec&);$/;"	p	class:Vec	access:public	signature:(const Vec&)
Vec::operator []	vec.h	/^	T& operator[](size_type i) { return data[i]; }$/;"	f	class:Vec	access:public	signature:(size_type i)
Vec::operator []	vec.h	/^	const T& operator[](size_type i) { return data[i]; }$/;"	f	class:Vec	access:public	signature:(size_type i)
Vec::push_back	vec.h	/^	void push_back(const T& t) {$/;"	f	class:Vec	access:public	signature:(const T& t)
Vec::reference	vec.h	/^	typedef T& reference;$/;"	t	class:Vec	access:public
Vec::size	vec.h	/^	size_type size() const { return avail - data; }$/;"	f	class:Vec	access:public	signature:() const
Vec::size_type	vec.h	/^	typedef size_t size_type;$/;"	t	class:Vec	access:public
Vec::unchecked_append	vec.h	/^	void unchecked_append(const T&);$/;"	p	class:Vec	access:private	signature:(const T&)
Vec::uncreate	vec.h	/^	void uncreate();$/;"	p	class:Vec	access:private	signature:()
Vec::value_type	vec.h	/^	typedef T value_type;$/;"	t	class:Vec	access:public
Vec::~Vec	vec.h	/^	~Vec() { uncreate(); } 	$/;"	f	class:Vec	access:public	signature:()
alloc	vec.h	/^	allocator<T> alloc;$/;"	m	class:Vec	access:private
avail	vec.h	/^	iterator avail; \/\/ one past last element in the Vec$/;"	m	class:Vec	access:private
begin	vec.h	/^	const_iterator begin() { return data; }$/;"	f	class:Vec	access:public	signature:()
begin	vec.h	/^	iterator begin() { return data; }$/;"	f	class:Vec	access:public	signature:()
const_iterator	vec.h	/^	typedef const T* const_iterator;$/;"	t	class:Vec	access:public
const_reference	vec.h	/^	typedef const T& const_reference;$/;"	t	class:Vec	access:public
create	vec.h	/^	void create();$/;"	p	class:Vec	access:private	signature:()
create	vec.h	/^	void create(const_iterator, const_iterator);$/;"	p	class:Vec	access:private	signature:(const_iterator, const_iterator)
create	vec.h	/^	void create(size_type, const T&);$/;"	p	class:Vec	access:private	signature:(size_type, const T&)
data	vec.h	/^	iterator data; \/\/ first element in the Vec$/;"	m	class:Vec	access:private
end	vec.h	/^	const_iterator end() const { return avail; }$/;"	f	class:Vec	access:public	signature:() const
end	vec.h	/^	iterator end() const { return avail; }$/;"	f	class:Vec	access:public	signature:() const
grow	vec.h	/^	void grow();$/;"	p	class:Vec	access:private	signature:()
iterator	vec.h	/^	typedef T* iterator;$/;"	t	class:Vec	access:public
limit	vec.h	/^	iterator limit; \/\/ one past allocated array$/;"	m	class:Vec	access:private
operator =	vec.h	/^	Vec& operator=(const Vec&);$/;"	p	class:Vec	access:public	signature:(const Vec&)
operator []	vec.h	/^	T& operator[](size_type i) { return data[i]; }$/;"	f	class:Vec	access:public	signature:(size_type i)
operator []	vec.h	/^	const T& operator[](size_type i) { return data[i]; }$/;"	f	class:Vec	access:public	signature:(size_type i)
push_back	vec.h	/^	void push_back(const T& t) {$/;"	f	class:Vec	access:public	signature:(const T& t)
reference	vec.h	/^	typedef T& reference;$/;"	t	class:Vec	access:public
size	vec.h	/^	size_type size() const { return avail - data; }$/;"	f	class:Vec	access:public	signature:() const
size_type	vec.h	/^	typedef size_t size_type;$/;"	t	class:Vec	access:public
unchecked_append	vec.h	/^	void unchecked_append(const T&);$/;"	p	class:Vec	access:private	signature:(const T&)
uncreate	vec.h	/^	void uncreate();$/;"	p	class:Vec	access:private	signature:()
value_type	vec.h	/^	typedef T value_type;$/;"	t	class:Vec	access:public
~Vec	vec.h	/^	~Vec() { uncreate(); } 	$/;"	f	class:Vec	access:public	signature:()
